<!DOCTYPE html>
<html>
<head>
    <title>RAW SQL → Drizzle Schema Code Generator</title>
    <meta charset="utf-8" />
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
      textarea { width: 100%; max-width: 960px; height: 220px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
      .btn { display: inline-block; margin: 6px 8px 6px 0; padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px; background:#f7f7f7; cursor:pointer; }
      .btn-primary { background:#1e90ff; color:#fff; border-color:#1e90ff; }
      .row { margin: 8px 0; }
      pre { background:#0b1021; color:#e6e6e6; padding: 16px; border-radius: 8px; max-width: 960px; overflow: auto; }
      .hint { color:#666; font-size: 13px; }
    </style>
</head>
<body>
    <h1>RAW SQL → Drizzle Schema Code Generator</h1>

    <form id="sqlForm" method="POST">
        <div class="row">
          <textarea id="sqlInput" name="sql" placeholder="Paste your CREATE TABLE SQL here..."></textarea>
        </div>

        <div class="row">
          <button type="button" class="btn" id="btnAddPk">Add PK to first col</button>
          <button type="button" class="btn" id="btnAddIdentity">Add auto increment to first col</button>
          <button type="submit" class="btn btn-primary">Generate</button>
        </div>
        <div class="hint">Tip: The PK/auto-increment buttons modify the SQL in the textarea before submitting.</div>
    </form>

    {% if output %}
    <h2>Generated Drizzle Code:</h2>
    <pre id="drizzleOut">{{ output }}</pre>
    <button type="button" class="btn" id="btnCopy">Copy code</button>
    {% endif %}

<script>
(function() {
  const sqlInput = document.getElementById('sqlInput');
  const form = document.getElementById('sqlForm');

  function getCreateBody(sql) {
    // Find first (...) after CREATE TABLE and return indices and inner text
    const createIdx = sql.search(/CREATE\s+TABLE/i);
    if (createIdx === -1) return null;
    const openIdx = sql.indexOf('(', createIdx);
    if (openIdx === -1) return null;
    let depth = 0, closeIdx = -1;
    for (let i = openIdx; i < sql.length; i++) {
      const ch = sql[i];
      if (ch === '(') depth++;
      else if (ch === ')') {
        depth--;
        if (depth === 0) { closeIdx = i; break; }
      }
    }
    if (closeIdx === -1) return null;
    return { openIdx, closeIdx, inner: sql.slice(openIdx + 1, closeIdx) };
  }

  function splitTopLevel(inner) {
    // split by commas not inside parens
    const out = [];
    let buf = '', depth = 0;
    for (let i = 0; i < inner.length; i++) {
      const ch = inner[i];
      if (ch === '(') { depth++; buf += ch; }
      else if (ch === ')') { depth--; buf += ch; }
      else if (ch === ',' && depth === 0) { out.push(buf.trim()); buf = ''; }
      else { buf += ch; }
    }
    if (buf.trim()) out.push(buf.trim());
    return out;
  }

  function ensurePrimaryKeyOnFirstCol(sql) {
    const body = getCreateBody(sql);
    if (!body) return sql;

    const items = splitTopLevel(body.inner);
    if (!items.length) return sql;

    // Skip table-level constraints at start; find first column line
    let firstIdx = -1;
    for (let i = 0; i < items.length; i++) {
      const u = items[i].toUpperCase();
      if (!u.startsWith('PRIMARY KEY') &&
          !u.startsWith('FOREIGN KEY') &&
          !u.startsWith('UNIQUE') &&
          !u.startsWith('CHECK') &&
          !u.startsWith('CONSTRAINT')) {
        firstIdx = i; break;
      }
    }
    if (firstIdx === -1) return sql;

    let first = items[firstIdx];
    const u = first.toUpperCase();
    if (!/\bPRIMARY\s+KEY\b/.test(u)) {
      // Append PRIMARY KEY to the column definition
      // If line ends with a trailing comma in original context, we’re editing inside array items so no comma here
      first = first.replace(/\s+$/, '');
      first = first + ' PRIMARY KEY';
      items[firstIdx] = first;
    }

    const newInner = items.join(',\n  ');
    return sql.slice(0, body.openIdx + 1) + '\n  ' + newInner + '\n' + sql.slice(body.closeIdx);
  }

  function ensureIdentityOnFirstCol(sql) {
    const body = getCreateBody(sql);
    if (!body) return sql;

    const items = splitTopLevel(body.inner);
    if (!items.length) return sql;

    // Find first column definition
    let firstIdx = -1;
    for (let i = 0; i < items.length; i++) {
      const u = items[i].toUpperCase();
      if (!u.startsWith('PRIMARY KEY') &&
          !u.startsWith('FOREIGN KEY') &&
          !u.startsWith('UNIQUE') &&
          !u.startsWith('CHECK') &&
          !u.startsWith('CONSTRAINT')) {
        firstIdx = i; break;
      }
    }
    if (firstIdx === -1) return sql;

    let first = items[firstIdx];
    const u = first.toUpperCase();

    // Ensure integer type exists; if missing a type token, add INT after the column name
    // Pattern: <name> [type ...]
    const m = first.trim().match(/^([A-Za-z_]\w*)(\s+.+)?$/);
    if (m) {
      const name = m[1];
      const rest = m[2] ? m[2] : '';
      if (!/\b(BIGINT|SMALLINT|INT|INTEGER)\b/.test(rest.toUpperCase())) {
        first = name + ' INT' + (rest || '');
      }
    }

    // Add GENERATED ALWAYS AS IDENTITY
    if (!/\bGENERATED\s+(ALWAYS|BY\s+DEFAULT)\s+AS\s+IDENTITY\b/.test(first.toUpperCase())) {
      // place before PRIMARY KEY or at end
      if (/\bPRIMARY\s+KEY\b/.test(first.toUpperCase())) {
        first = first.replace(/\bPRIMARY\s+KEY\b/i, 'GENERATED ALWAYS AS IDENTITY PRIMARY KEY');
      } else {
        first = first.replace(/\s+$/, '') + ' GENERATED ALWAYS AS IDENTITY';
      }
    }

    // Ensure PRIMARY KEY exists
    if (!/\bPRIMARY\s+KEY\b/.test(first.toUpperCase())) {
      first = first.replace(/\s+$/, '') + ' PRIMARY KEY';
    }

    items[firstIdx] = first;
    const newInner = items.join(',\n  ');
    return sql.slice(0, body.openIdx + 1) + '\n  ' + newInner + '\n' + sql.slice(body.closeIdx);
  }

  document.getElementById('btnAddPk').addEventListener('click', function() {
    const sql = sqlInput.value || '';
    const updated = ensurePrimaryKeyOnFirstCol(sql);
    sqlInput.value = updated;
  });

  document.getElementById('btnAddIdentity').addEventListener('click', function() {
    const sql = sqlInput.value || '';
    const updated = ensureIdentityOnFirstCol(sql);
    sqlInput.value = updated;
  });

  const btnCopy = document.getElementById('btnCopy');
  if (btnCopy) {
    btnCopy.addEventListener('click', async function() {
      const pre = document.getElementById('drizzleOut');
      if (!pre) return;
      try {
        await navigator.clipboard.writeText(pre.textContent || '');
        btnCopy.textContent = 'Copied!';
        setTimeout(() => (btnCopy.textContent = 'Copy code'), 1200);
      } catch (e) {
        // Fallback if Clipboard API not available
        const ta = document.createElement('textarea');
        ta.value = pre.textContent || '';
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        btnCopy.textContent = 'Copied!';
        setTimeout(() => (btnCopy.textContent = 'Copy code'), 1200);
      }
    });
  }
})();
</script>
</body>
</html>